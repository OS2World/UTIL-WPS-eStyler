//===========================================================================\
// ApiExPM.h: General purpose PM macros and definitions
//            These definitions are meant to be available to any program
// 24-12-2001 * by Alessandro Cantatore * v...
//===========================================================================/


#ifndef _APIEX_PM_H_
   #define _APIEX_PM_H_

// new type definitions
// image handle : this is used by the control which can display both icons
// and bitmaps
typedef LHANDLE HIMAGE;
typedef HIMAGE * PHIMAGE;

// Message result definitions
#define MRFALSE ((MRESULT)0)
#define MRTRUE  ((MRESULT)1)
// Message parameter definitions
#define MPFALSE ((MPARAM)0)
#define MPTRUE  ((MPARAM)1)

// Undocumented window style
#ifndef WS_TOPMOST
#define WS_TOPMOST  0x00200000
#endif

// Undocumented messages generated by Warp 4 and superior versions
// These messages are posted to a window when the mouse pointer enters
// or leaves the window rectangle.
// The default window procedure returns FALSE in both cases

// mouse getting inside the window area
// mp1 : handle of the window the mouse is moving to
// mp2 : handle of the window previously under the mouse
#define WM_MOUSEENTER      0x041e

// mouse getting outside the window area
// mp1 : handle of the window the mouse is moving away from
// mp2 : handle of the window the mouse is moving to
#define WM_MOUSEEXIT       0x041f    // mouse leaving the window area


// gets x, y coordinates from a mouse message parameter
#define MOUSEX(mp)          ((SHORT)(ULONG)(mp))
#define MOUSEY(mp)          ((SHORT)((ULONG)mp >> 16))

// New system pointer: display a hand with a finger
#define SPTR_HANDCLICK   (SPTR_CPTR + 1)
// Macro to set a system pointer (used in WM_MOUSEMOVE processing)
#define WinSetSysPointer(iptr) \
   (WinSetPointer(HWND_DESKTOP, WinQuerySysPointer(HWND_DESKTOP, (iptr), 0)))


// general PM query window macros
#define WinHAB(hwnd)         (WinQueryAnchorBlock(hwnd))
#define WinID(hwnd)          (WinQueryWindowUShort((hwnd), QWS_ID))
#define WinNext(hwnd)        (WinQueryWindow((hwnd), QW_NEXT))
#define WinOwner(hwnd)       (WinQueryWindow((hwnd), QW_OWNER))
#define WinParent(hwnd)      (WinQueryWindow((hwnd), QW_PARENT))
#define WinStyle(hwnd)       (WinQueryWindowULong((hwnd), QWL_STYLE))
#define WinStyleSet(hwnd, style) \
   (WinSetWindowULong((hwnd), QWL_STYLE, (style)))

// WinQuerySysValue () macro
#define WinSysVal(ival)      (WinQuerySysValue(HWND_DESKTOP, (ival)))

// general dialog macros
#define DlgItemHwnd(hwnd, id)    (WinWindowFromID((hwnd), (id)))
#define DlgItemEnable(hwnd, id, benable) \
   (WinEnableWindow(DlgItemHwnd((hwnd), (id)), (benable)))
#define DlgItemIsEnabled(hwnd, id) \
   (WinIsWindowEnabled(DlgItemHwnd((hwnd), (id))))
#define DlgItemShow(hwnd, id, bshow) \
   (WinShowWindow(DlgItemHwnd((hwnd), (id)), (bshow)))
#define DlgItemIsVisible(hwnd, id) \
   (WinIsWindowVisible(DlgItemHwnd((hwnd), (id))))
#define DlgItemGetPos(hwnd, id, pswp) \
   (WinQueryWindowPos(WinWindowFromID((hwnd), (id)), (pswp)))
#define DlgItemSetPos(hwnd, id, hBehind, x, y, cx, cy, fl) \
   (WinSetWindowPos(WinWindowFromID((hwnd), (id)), \
                    (hBehind), (x), (y), (cx), (cy), (fl)))

// general purpose point and rectangle manipulation macros
// the ppt and prect parameters must be pointer to POINT and RECTL
// Initializes a point structure
#define PointSet(ppt, _x, _y)   \
  (((PPOINTL)(ppt))->x = (_x),  \
   ((PPOINTL)(ppt))->y = (_y))
// Simmetrically shifts the rectangle coordinates by dx,dy pixels
#define RectInflate(prect, dx, dy)                                \
                           (((PRECTL)(prect))->xLeft -= (dx),     \
                            ((PRECTL)(prect))->yBottom -= (dy),   \
                            ((PRECTL)(prect))->xRight += (dx),    \
                            ((PRECTL)(prect))->yTop += (dy))
// Initializes a rectangle with the coordinates (x0,y0) - (x1,y1)
#define RectSet(prect, x0, y0, x1, y1)                            \
                           (((PRECTL)(prect))->xLeft = (x0),      \
                            ((PRECTL)(prect))->yBottom = (y0),    \
                            ((PRECTL)(prect))->xRight = (x1),     \
                            ((PRECTL)(prect))->yTop = (y1))
// shifts the coordinates of a rectangle by dx, dy pixels
#define RectShift(prect, dx, dy)                                  \
                           (((PRECTL)(prect))->xLeft += (dx),     \
                            ((PRECTL)(prect))->yBottom += (dy),   \
                            ((PRECTL)(prect))->xRight += (dx),    \
                            ((PRECTL)(prect))->yTop += (dy))
// returns TRUE if a RECTL structure is empty
#define RectIsEmpty(prect)                                        \
((((PRECTL)(prect))->xLeft >= ((PRECTL)(prect))->xRight) ||       \
 (((PRECTL)(prect))->yBottom >= ((PRECTL)(prect))->yTop))

// top and right coordinates of a window used with WinSetMultWindowPos()
#define mwposXright(pswp, idx) ((pswp)[idx].x + (pswp)[idx].cx)
#define mwposYtop(pswp, idx)   ((pswp)[idx].y + (pswp)[idx].cy)


// ENTRY FIELD macros ------------------------------------------------------

// changes the readonly style of the entry field
#define dEfSetReadOnly(hwnd, id, bReadOnly) \
   ((BOOL)WinSendDlgItemMsg((hwnd), (id), EM_SETREADONLY, \
                            (MPARAM)(bReadOnly), MPVOID))
#define wEfSetReadOnly(hwnd, bReadOnly) \
   ((BOOL)WinSendMsg((hwnd), EM_SETREADONLY, (MPARAM)(bReadOnly), MPVOID))

// changes the maximum size of the text allowed for an entry field
#define dEfSetTextLimit(hwnd, id, limit) \
   ((BOOL)WinSendDlgItemMsg((hwnd), (id), EM_SETTEXTLIMIT, \
                            (MPARAM)(limit), MPVOID))
#define wEfSetTextLimit(hwnd, limit) \
   ((BOOL)WinSendMsg((hwnd), EM_SETTEXTLIMIT, (MPARAM)(limit), MPVOID))


// SCROLL BAR macros -------------------------------------------------------
#define dScrollPosSet(hwnd, id, ipos) \
   ((BOOL)WinSendDlgItemMsg((hwnd), (id), SBM_SETPOS, \
                            MPFROMSHORT(ipos), MPVOID))
#define wScrollPosSet(hwnd, ipos) \
   ((BOOL)WinSendMsg((hwnd), SBM_SETPOS, MPFROMSHORT(ipos), MPVOID))

// Menu macros -------------------------------------------------------------

// creates a submenu to be dynamically inserted in a menu
// hwnd : parent menu handle
#define WinCreateSubmenu(hwnd) \
((HWND)WinCreateWindow(HWND_OBJECT, WC_MENU, NULL, 0, 0, 0, 0, 0, (hwnd), \
                       HWND_TOP, 0, NULL, NULL))

// inserts a menu item
// hwnd     : parent menu handle
// pmi      : address of MENUITEM structure
// itemText : item text
#define wMenuItemIns(hwnd, pmi, itemText) \
((SHORT)WinSendMsg((hwnd), MM_INSERTITEM, (MPARAM)(pmi), (MPARAM)(itemText)))

// check/unchecks menuitem id
#define wMenuItemCheck(hwnd, id) \
   ((BOOL)WinSendMsg(hwnd, MM_SETITEMATTR, MPFROM2SHORT(id, TRUE), \
                     MPFROM2SHORT(MIA_CHECKED, MIA_CHECKED)))
#define wMenuItemUncheck(hwnd, id) \
   ((BOOL)WinSendMsg(hwnd, MM_SETITEMATTR, MPFROM2SHORT(id, TRUE), \
                     MPFROM2SHORT(MIA_CHECKED, 0)))

// changes the text of the menuitem id
#define wMenuItemTextSet(hwnd, id, text) \
   ((BOOL)WinSendMsg((hwnd), MM_SETITEMTEXT, (MPARAM)(id), (MPARAM)(text)))


// d* macro are for dialogs, w* macro are for windows
// BUTTONS -----------------------------------------------------------------

// emulate a click event on a button
#define dBtnClick(hwnd, id, bUp) \
   ((USHORT)WinSendDlgItemMsg((hwnd), (id), BM_CLICK, (MPARAM)(bUp), MPVOID))
#define wBtnClick(hwnd, bUp) \
   ((USHORT)WinSendMsg((hwnd), BM_CLICK, (MPARAM)(bUp), MPVOID))

// sets a button check state
#define dBtnCheckSet(hwnd, id, state) \
   ((USHORT)WinSendDlgItemMsg((hwnd), (id), BM_SETCHECK, \
                              (MPARAM)(state), MPVOID))
#define wBtnCheckSet(hwnd, state) \
   ((USHORT)WinSendMsg((hwnd), BM_SETCHECK, (MPARAM)(state), MPVOID))

// gets a button check state
#define dBtnCheckState(hwnd, id) \
   ((USHORT)WinSendDlgItemMsg((hwnd), (id), BM_QUERYCHECK, MPVOID, MPVOID))
#define wBtnCheckState(hwnd) \
   ((USHORT)WinSendMsg((hwnd), BM_QUERYCHECK, MPVOID, MPVOID))

// returns the check index of a group of radiobutton (0 = first radiobutton)
#define dBtnCheckIndex(hwnd, id) \
   ((SHORT)WinSendDlgItemMsg((hwnd), (id), BM_QUERYCHECKINDEX, MPVOID, MPVOID))
#define wBtnCheckIndex(hwnd) \
   ((SHORT)WinSendMsg((hwnd), BM_QUERYCHECKINDEX, MPVOID, MPVOID))

// d* macro are for dialogs, w* macro are for windows
// CONTAINERS --------------------------------------------------------------

// allocates one minirecordcore type structure
// (cb is the total size of the structure to be allocated)
#define dCnrAllocMini(hwnd, id, cb) \
((PMINIRECORDCORE)WinSendDlgItemMsg((hwnd), (id), CM_ALLOCRECORD, \
                                    (MPARAM)((cb) - sizeof(MINIRECORDCORE)),\
                                    (MPARAM)1))
#define wCnrAllocMini(hwnd, cb) \
((PMINIRECORDCORE)WinSendMsg((hwnd), CM_ALLOCRECORD, \
                             (MPARAM)((cb) - sizeof(MINIRECORDCORE)),\
                             (MPARAM)1))

// allocates multiple minirecordcore type structures
// (cb is the total size of the structure to be allocated)
#define dCnrAllocMultiMini(hwnd, id, cb, cRec) \
((PMINIRECORDCORE)WinSendDlgItemMsg((hwnd), (id), CM_ALLOCRECORD, \
                                    (MPARAM)((cb) - sizeof(MINIRECORDCORE)),\
                                    (MPARAM)(cRec)))
#define wCnrAllocMultiMini(hwnd, cb, cRec) \
((PMINIRECORDCORE)WinSendMsg((hwnd), CM_ALLOCRECORD, \
                             (MPARAM)((cb) - sizeof(MINIRECORDCORE)),\
                             (MPARAM)(cRec)))

// Allocates the structures describing the columns when in detail view
#define dCnrAllocColumns(hwnd, id, cCols) \
((PFIELDINFO)WinSendDlgItemMsg((hwnd), (id), CM_ALLOCDETAILFIELDINFO, \
                               (MPARAM)(cCols), MPVOID))
#define wCnrAllocColumns(hwnd, cCols) \
((PFIELDINFO)WinSendMsg((hwnd), CM_ALLOCDETAILFIELDINFO, \
                        (MPARAM)(cCols), MPVOID))

// Frees the structures describing the columns when in detail view
#define dCnrFreeColumns(hwnd, id, pCol, cCols) \
((PFIELDINFO)WinSendDlgItemMsg((hwnd), (id), CM_FREEDETAILFIELDINFO, \
                               (MPARAM)(pCol), (MPARAM)(cCols)))
#define wCnrFreeColumns(hwnd, pCol, cCols) \
((PFIELDINFO)WinSendMsg((hwnd), CM_FREEDETAILFIELDINFO, \
                        (MPARAM)(pCol), (MPARAM)(cCols)))

// query a field info (CMA_FIRST, CMA_LAST, CMA_NEXT, CMA_PREV)
#define dCnrGetFieldInfo(hwnd, id, pfi, idx) \
((PFIELDINFO)WinSendDlgItemMsg((hwnd), (id), CM_QUERYDETAILFIELDINFO, \
                         (MPARAM)(pfi), (MPARAM)(idx)))
#define wCnrGetFieldInfo(hwnd, pfi, idx) \
((PFIELDINFO)WinSendMsg((hwnd), CM_QUERYDETAILFIELDINFO, \
                        (MPARAM)(pfi), (MPARAM)(idx)))


// Arranges the content of a container
#define dCnrArrange(hwnd, id, type, flag) \
((BOOL)WinSendDlgItemMsg((hwnd), (id), CM_ARRANGE, \
                         (MPARAM)(type), (MPARAM)(flag)))
#define wCnrArrange(hwnd, type, flag) \
((BOOL)WinSendMsg((hwnd), CM_ARRANGE, (MPARAM)(type), (MPARAM)(flag)))

// inserts one minirecordcore type structure in a container
#define dCnrInsMini(hwnd, id, pRec, pRecIns) \
((ULONG)WinSendDlgItemMsg((hwnd), (id), CM_INSERTRECORD, \
                             (MPARAM)(pRec), (MPARAM)(pRecIns)))
#define wCnrInsMini(hwnd, pRec, pRecIns) \
((ULONG)WinSendMsg((hwnd), CM_INSERTRECORD, (MPARAM)(pRec), (MPARAM)(pRecIns)))

// inserts one or more columns in a container
#define dCnrInsColumns(hwnd, id, pFi, pFiIns) \
((ULONG)WinSendDlgItemMsg((hwnd), (id), CM_INSERTDETAILFIELDINFO, \
                             (MPARAM)(pFi), (MPARAM)(pFiIns)))
#define wCnrInsColumns(hwnd, pFi, pFiIns) \
((ULONG)WinSendMsg((hwnd), CM_INSERTDETAILFIELDINFO, \
                   (MPARAM)(pFi), (MPARAM)(pFiIns)))

// set the container info
#define dCnrInfoSet(hwnd, id, pci, flags) \
((BOOL)WinSendDlgItemMsg((hwnd), (id), CM_SETCNRINFO, \
                             (MPARAM)(pci), (MPARAM)(flags)))
#define wCnrInfoSet(hwnd, pci, flags) \
((BOOL)WinSendMsg((hwnd), CM_SETCNRINFO, (MPARAM)(pci), (MPARAM)(flags)))

// get a container record
#define dCnrGetRecord(hwnd, id, pRec, iRec, order) \
((BOOL)WinSendDlgItemMsg((hwnd), (id), CM_QUERYRECORD, \
                         (MPARAM)(pRec), MPFROM2SHORT((iRec), (order))))
#define wCnrGetRecord(hwnd, pRec, iRec, order) \
((BOOL)WinSendMsg((hwnd), CM_QUERYRECORD, \
                  (MPARAM)(pRec), MPFROM2SHORT((iRec), (order))))

// removes and frees all the container records
#define dCnrRemAllRecords(hwnd, id) \
((BOOL)WinSendDlgItemMsg((hwnd), (id), CM_REMOVERECORD, \
                         MPVOID, MPFROM2SHORT(0, CMA_FREE | CMA_INVALIDATE)))
#define wCnrRemAllRecords(hwnd) \
((BOOL)WinSendMsg((hwnd), CM_REMOVERECORD, \
                  MPVOID, MPFROM2SHORT(0, CMA_FREE | CMA_INVALIDATE)))

// return the address of the first selected container record
#define dCnrSelectedRecord(hwnd, id) \
((PVOID)WinSendDlgItemMsg((hwnd), (id), CM_QUERYRECORDEMPHASIS, \
                          (MPARAM)CMA_FIRST, (MPARAM)CRA_SELECTED))
#define wCnrSelectedRecord(hwnd) \
((PVOID)WinSendMsg((hwnd), CM_QUERYRECORDEMPHASIS, \
                   (MPARAM)CMA_FIRST, (MPARAM)CRA_SELECTED))

// returns TRUE if 'p' returned by wCnrSelectedRecord is a valid address
#define wCnrIsValidRecord(p)   ((p) && ((INT)(p) != -1))

// redraws a container record
#define dCnrRedrawRecord(hwnd, id, prec, crec, flag) \
((PVOID)WinSendDlgItemMsg((hwnd), (id), CM_INVALIDATERECORD, \
                          (MPARAM)(prec), MPFROM2SHORT((crec), (flag))))
#define wCnrRedrawRecord(hwnd, prec, crec, flag) \
((PVOID)WinSendMsg((hwnd), CM_INVALIDATERECORD, \
                   (MPARAM)(prec), MPFROM2SHORT((crec), (flag))))

// select a container record
#define dCnrSelectRecord(hwnd, id, prec, bsel) \
((BOOL)WinSendDlgItemMsg((hwnd), (id), CM_SETRECORDEMPHASIS, \
                          (MPARAM)(prec), MPFROM2SHORT((bsel), CRA_SELECTED)))
#define wCnrSelectRecord(hwnd, prec, bsel) \
((BOOL)WinSendMsg((hwnd), CM_SETRECORDEMPHASIS, \
                   (MPARAM)(prec), MPFROM2SHORT((bsel), CRA_SELECTED)))

// disable/enable a container record
#define dCnrDisableRecord(hwnd, id, prec, bdisable) \
((BOOL)WinSendDlgItemMsg((hwnd), (id), CM_SETRECORDEMPHASIS, \
                          (MPARAM)(prec), MPFROM2SHORT((bdisable), CRA_DISABLED)))
#define wCnrDisableRecord(hwnd, prec, bdisable) \
((BOOL)WinSendMsg((hwnd), CM_SETRECORDEMPHASIS, \
                   (MPARAM)(prec), MPFROM2SHORT((bdisable), CRA_DISABLED)))

// sets the emphasis attributes of the specified container record
#define dCnrEmphasizeRecord(hwnd, id, prec, bool, flag) \
((BOOL)WinSendDlgItemMsg((hwnd), (id), CM_SETRECORDEMPHASIS, \
                          (MPARAM)(prec), MPFROM2SHORT((bool), (flag))))
#define wCnrEmphasizeRecord(hwnd, prec, bool, flag) \
((BOOL)WinSendMsg((hwnd), CM_SETRECORDEMPHASIS, \
                   (MPARAM)(prec), MPFROM2SHORT((bool), (flag))))

// d* macro are for dialogs, w* macro are for windows
// listbox -----------------------------------------------------------------
// delete all items

#define dLbxEmpty(hwnd, id) \
   ((BOOL)WinSendDlgItemMsg((hwnd), (id), LM_DELETEALL, MPVOID, MPVOID))
#define wLbxEmpty(hwnd) \
   ((BOOL)WinSendMsg((hwnd), LM_DELETEALL, MPVOID, MPVOID))

// insert an item

#define dLbxItemIns(hwnd, id, iitem, pitem) \
   ((SHORT)WinSendDlgItemMsg((hwnd), (id), LM_INSERTITEM, \
                             (MPARAM)(iitem), (MPARAM)(pitem)))
#define wLbxItemIns(hwnd, iitem, pitem) \
   ((SHORT)WinSendMsg((hwnd), LM_INSERTITEM, \
                      (MPARAM)(iitem), (MPARAM)(pitem)))

// insert an item and a handle
#define dLbxItemAndHndIns(hwnd, id, iitem, pitem, hnd) \
((BOOL)WinSendDlgItemMsg((hwnd), (id), LM_SETITEMHANDLE, \
                    (MPARAM)WinSendDlgItemMsg((hwnd), (id), LM_INSERTITEM,\
                                       (MPARAM)(iitem), (MPARAM)(pitem)), \
                    (MPARAM)(hnd)))
#define wLbxItemAndHndIns(hwnd, iitem, pitem, hnd) \
((BOOL)WinSendMsg((hwnd), LM_SETITEMHANDLE, \
                  (MPARAM)WinSendMsg((hwnd), LM_INSERTITEM,\
                                     (MPARAM)(iitem), (MPARAM)(pitem)), \
                  (MPARAM)(hnd)))

// query the first selected item
#define dLbxItemSelected(hwnd, id) \
   ((SHORT)WinSendDlgItemMsg((hwnd), (id), LM_QUERYSELECTION, \
                             (MPARAM)LIT_FIRST, MPVOID))
#define wLbxItemSelected(hwnd) \
   ((SHORT)WinSendMsg((hwnd), LM_QUERYSELECTION, (MPARAM)LIT_FIRST, MPVOID))

// get the item count
#define dLbxItemCount(hwnd, id) \
   ((SHORT)WinSendDlgItemMsg((hwnd), (id), LM_QUERYITEMCOUNT, MPVOID, MPVOID))
#define wLbxItemCount(hwnd) \
   ((SHORT)WinSendMsg((hwnd), LM_QUERYITEMCOUNT, MPVOID, MPVOID))

// get the handle of an item

#define dLbxItemHnd(hwnd, id, iitem) \
   ((ULONG)WinSendDlgItemMsg((hwnd), (id), LM_QUERYITEMHANDLE, \
                             (MPARAM)(iitem), MPVOID))
#define wLbxItemHnd(hwnd, iitem) \
   ((ULONG)WinSendMsg((hwnd), LM_QUERYITEMHANDLE, (MPARAM)(iitem), MPVOID))

// set the handle of an item

#define dLbxItemHndSet(hwnd, id, iitem, handle) \
   ((ULONG)WinSendDlgItemMsg((hwnd), (id), LM_SETITEMHANDLE, \
                             (MPARAM)(iitem), (MPARAM)(handle)))
#define wLbxItemHndSet(hwnd, iitem, handle) \
   ((ULONG)WinSendMsg((hwnd), LM_SETITEMHANDLE, \
                      (MPARAM)(iitem), (MPARAM)(handle)))
// select an item
#define dLbxItemSelect(hwnd, id, iitem) \
   ((BOOL)WinSendDlgItemMsg((hwnd), (id), LM_SELECTITEM, \
                             (MPARAM)(iitem), (MPARAM)TRUE))
#define wLbxItemSelect(hwnd, iitem) \
   ((BOOL)WinSendMsg((hwnd), LM_SELECTITEM, (MPARAM)(iitem), (MPARAM)TRUE))

// get the text of the item iitem
#define dLbxItemText(hwnd, id, iitem, cbBuf, pszText) \
   ((SHORT)WinSendDlgItemMsg((hwnd), (id), LM_QUERYITEMTEXT, \
                      MPFROM2SHORT((iitem), (cbBuf)), (MPARAM)(pszText)))
#define wLbxItemText(hwnd, iitem, cbBuf, pszText) \
   ((SHORT)WinSendMsg((hwnd), LM_QUERYITEMTEXT, \
                      MPFROM2SHORT((iitem), (cbBuf)), (MPARAM)(pszText)))

// find an item from its text
#define dLbxItemTextSearch(hwnd, id, flSearch, iStart, pszText) \
   ((SHORT)WinSendDlgItemMsg((hwnd), (id), LM_SEARCHSTRING, \
                      MPFROM2SHORT((flSearch), (iStart)), (MPARAM)(pszText)))
#define wLbxItemTextSearch(hwnd, flSearch, iStart, pszText) \
   ((SHORT)WinSendMsg((hwnd), LM_SEARCHSTRING, \
                      MPFROM2SHORT((flSearch), (iStart)), (MPARAM)(pszText)))

// query the handle of the first selected item
#define dLbxItemSelectedHnd(hwnd, id) \
   dLbxItemHnd((hwnd), (id), dLbxItemSelected((hwnd), (id)))

#define wLbxItemSelectedHnd(hwnd) \
   wLbxItemHnd((hwnd), wLbxItemSelected(hwnd))

// spin button macros -----------------------------------------------------

#define dSpinBtnSetArray(hwnd, id, aPsz, cPsz) \
   ((BOOL)WinSendDlgItemMsg((hwnd), (id), SPBM_SETARRAY, \
                            (MPARAM)(aPsz), (MPARAM)(cPsz)))
#define wSpinBtnSetArray(hwnd, aPsz, cPsz) \
   ((BOOL)WinSendMsg((hwnd), SPBM_SETARRAY, (MPARAM)(aPsz), (MPARAM)(cPsz)))

#define dSpinBtnSetValue(hwnd, id, value) \
   ((BOOL)WinSendDlgItemMsg((hwnd), (id), SPBM_SETCURRENTVALUE, \
                            (MPARAM)(value), MPVOID))
#define wSpinBtnSetValue(hwnd, value) \
   ((BOOL)WinSendMsg((hwnd), SPBM_SETCURRENTVALUE, (MPARAM)(value), MPVOID))

#define dSpinBtnSetLimits(hwnd, id, bottom, top) \
   ((BOOL)WinSendDlgItemMsg((hwnd), (id), SPBM_SETLIMITS, \
                            (MPARAM)(top), (MPARAM)(bottom)))
#define wSpinBtnSetLimits(hwnd, bottom, top) \
   ((BOOL)WinSendMsg((hwnd), SPBM_SETLIMITS, (MPARAM)(top), (MPARAM)(bottom)))


#endif // #ifndef _APIEX_PM_H_
